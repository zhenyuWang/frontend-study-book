<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>5种基础排序</title>
</head>
<body>
  <script>
    /* 
      选择排序
      思想：每次找出当前数组中的最小（最大）元素，将其放入结果数组
    */
    let arr = [5,4,3,2,1,9,8,7,6,0]
    function selectSort(arr){
      const ret = [];
      function getMinIndex(arr){
        if(arr.length === 0) return null;
        if(arr.length ===1) return 0;
        let ind = 0;
        for(let i = 1;i<arr.length;i++){
          if(arr[ind]>arr[i]) ind = i;
        }
        return ind;
      }
      while(arr.length){
        ret.push(arr.splice(getMinIndex(arr),1))
      }
      return ret;
    }
    console.log(selectSort(arr))

    /* 
      插入排序
      思想：每次将新的值插入到有序数组的适当位置，类似于扑克牌的整理过程
    */
    arr = [5,4,3,2,1,9,8,7,6,0]
    function insertSort(arr){
      let ret = [];
      function insert(arr,val){
        let ind = 0;
        while(arr[ind]<val&&ind<arr.length) ind++;
        arr.splice(ind,0,val)
        return arr;
      }
      while(arr.length){
        ret = insert(ret,arr.pop())
      }
      return ret;
    }
    console.log(insertSort(arr))

    /* 
      冒泡排序
      思想：每次将剩余待排序的值中最小（大）值放到外层循环下标位置
      就像水中的气泡向上漂浮一样，只不过这里是限制的数组中的
    */
    arr = [5,4,3,2,1,9,8,7,6,0]
    function bubbleSort(arr){
      for(let i = 0;i<arr.length-1;i++){
        for(let j = i+1;j<arr.length;j++){
          if(arr[i]>arr[j]){
            [arr[i],arr[j]] = [arr[j],arr[i]]
          }
        }
      }
      return arr;
    }
    console.log(bubbleSort(arr))

    /* 
      希尔排序
      思想：通过步长，从后向前比较间隔为步长的两个元素的大小，如果增序排列且后边的值小于前面的值，则互换位置
      这样每次完成后每一组步长内的元素是有序的
      步长每次/2 直到步长为1，整个数组有序
    */
    arr = [5,4,3,2,1,9,8,7,6,0]
    function shellSort(arr){
      let len = arr.length,j
      for(let groupNum = (len>>1);0<groupNum;groupNum = groupNum >> 1){
          for(let i = groupNum;i<len;i++){
            const tmp = arr[i]
            for(j = i;groupNum<=j&&tmp<arr[j-groupNum];j-=groupNum){
              arr[j] = arr[j-groupNum]
            }
            arr[j] = tmp;
          }
      }
      return arr;
    }
    console.log(shellSort(arr))

    /* 
      快速排序
      思想：取数组中的某一项为基准，并将小于该基准的放到left,大于等于该基准的放到right,直到数组元素个数小于等于1个
      回溯过程中有序拼接，即可组成有序数组
    */
    arr = [5,4,3,2,1,9,8,7,6,0]
    function quickSort(arr){
      if(arr.length <= 1) return arr;
      const base = arr.pop(),
      left = [],right = [];
      for(let i = 0;i<arr.length;i++){
        if(arr[i]<base) left.push(arr[i])
        else right.push(arr[i])
      }
      return quickSort(left).concat(base,quickSort(right))
    }
    console.log(quickSort(arr))

    /* 
      归并排序
      思想：不断将数组从中间拆分为两部分，直到数组中只有一个元素
      在回溯的过程中左右数组为有序数组，每次取左右数组第一个元素（即最小元素）进行比较，将更小的拿出，放到结果数组，直到一方为空
      组合新数组和剩余数组的元素并返回
    */
    arr = [5,4,3,2,1,9,8,7,6,0]
    function mergeSort(arr){
      if(arr.length<2) return arr;
      let middle = arr.length >> 1;
      function merge(left,right){
        let res = [];
        while(left.length&&right.length){
          if(left[0]<right[0]){
            res.push(left.shift())
          }else{
            res.push(right.shift())
          }
        }
        return [...res,...left,...right]
      }
      return merge(mergeSort(arr.slice(0,middle)),mergeSort(arr.slice(middle)))
    }
    console.log(mergeSort(arr))
  </script>
</body>
</html>